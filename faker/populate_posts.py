import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np


def database_connection_url():
    dotenv.load_dotenv()
    DB_USER: str = os.environ.get("POSTGRES_USER")
    DB_PASSWD = os.environ.get("POSTGRES_PASSWORD")
    DB_SERVER: str = os.environ.get("POSTGRES_SERVER")
    DB_PORT: str = os.environ.get("POSTGRES_PORT")
    DB_NAME: str = os.environ.get("POSTGRES_DB")
    return f"postgresql://{DB_USER}:{DB_PASSWD}@{DB_SERVER}:{DB_PORT}/{DB_NAME}"


# Create a new DB engine based on our connection string
engine = sqlalchemy.create_engine(
    database_connection_url(), use_insertmanyvalues=True)

with engine.begin() as conn:
    conn.execute(sqlalchemy.text("""
    DROP TABLE IF EXISTS "Reactions";
    DROP TABLE IF EXISTS "Profile";
    DROP TABLE IF EXISTS "Comments";
    DROP TABLE IF EXISTS "Posts";
    DROP TABLE IF EXISTS "Followers";
    DROP TABLE IF EXISTS "ProfileReactions";
    DROP TABLE IF EXISTS "User";

    -- Profile Table
    create table public."Profile" (
        "id" bigint generated by default as identity not null,
        "created_at" timestamp with time zone not null default now(),
        "owner_id" bigint not null,
        "about_me" text default '"I''m secretive."'::text,
        "public" boolean default true
    );

    -- Reactions Table
    create table public."Reactions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "like" boolean,
    "post_id" bigint,
    "user_id" bigint
    );

    -- User Table
    create table
    public."User" (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        username text not null,
        password text not null,
        first_name text not null default ''::text,
        last_name text not null default ''::text,
        constraint User_pkey primary key (id),
        constraint User_username_key unique (username)
    ) tablespace pg_default;

    -- Posts Table
    create table
    public."Posts" (
        post_id bigint generated by default as identity,
        date timestamp with time zone not null default now(),
        user_id bigint null,
        post text not null,
        likes integer null default 0,
        dislikes integer null default 0,
        constraint Post_pkey primary key (post_id)
    ) tablespace pg_default;

    -- Followers Table
    create table
    public."Followers" (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        user_id bigint not null,
        follower_id integer not null,
        constraint Followers_pkey primary key (id),
        constraint Followers_user_id_fkey foreign key (user_id) references "User" (id)
    ) tablespace pg_default;

    -- Comments Table
    create table
    public."Comments" (
        id bigint generated by default as identity,
        date timestamp with time zone not null default now(),
        user_id bigint not null,
        post_id bigint null,
        content text not null,
        constraint Comment_pkey primary key (id),
        constraint Comment_post_id_fkey foreign key (post_id) references "Posts" (post_id),
        constraint Comments_user_id_fkey foreign key (user_id) references "User" (id)
    ) tablespace pg_default;


    -- trigger
    CREATE TRIGGER after_user_create AFTER INSERT ON public."User" FOR EACH ROW EXECUTE FUNCTION create_user_profile();
    ALTER TABLE "public"."User" ENABLE TRIGGER "after_user_create";

    --preload some values
    INSERT INTO "User" (username, password, first_name, last_name)
    VALUES ('jesus', 'pass', 'jesus', 'avalos')
    """))


num_users = 10000
fake = Faker()
posts_sample_distribution = np.random.default_rng(
).negative_binomial(0.15, 0.01, num_users)
comment_sample_distributions = np.random.default_rng(
).negative_binomial(0.3, 0.02, num_users)
reaction_sample_distribuions = np.random.default_rng(
).negative_binomial(0.3, 0.05, num_users)
total_posts = 0
follower_sample_distributions = np.random.default_rng(
).negative_binomial(0.3, 0.02, num_users)
total_posts = 0

# assigned true or false value for every user
profile_public = np.random.default_rng().random(num_users) > 0.3

# create fake posters with fake names and birthdays
with engine.begin() as conn:
    print("creating fake posters...")
    posts = []
    comments = []
    reactions = []
    followers = []
    for i in range(num_users):
        if (i % 10 == 0):
            print(i)

        password = fake.password(length=8)
        username = fake.unique.user_name()
        name = fake.name()

        # split name into first name and last name
        name = name.split(' ')
        first_name = name[0]
        last_name = name[1]
        created_at = fake.date_time_between(
            start_date="-1y", end_date='now', tzinfo=None)

        user_id = conn.execute(sqlalchemy.text("""
        INSERT INTO "User" (created_at, username, password, first_name, last_name)
        VALUES (:created_at, :username, :password, :first_name, :last_name) RETURNING id;
        """), {"created_at": created_at, "username": username, "password": password, "first_name": first_name, "last_name": last_name}).scalar_one()
        conn.execute(sqlalchemy.text("""
            UPDATE "Profile"
            SET public = :public, about_me = :about_me
            WHERE owner_id = :user_id
            """), {"user_id": user_id, "public": bool(profile_public[i]), "about_me": fake.sentence(15, True)})

        num_posts = posts_sample_distribution[i]
        for j in range(num_posts):
            total_posts += 1
            posts.append({
                "post": fake.text(),
                "user_id": user_id,
                "date": fake.date_time_between(start_date=created_at, end_date='now', tzinfo=None),
            })
        # create a random number of comments per each user based on existing posts, i.f.f user count > 15
        if i > 15:
            viewed_posts = set()
            posts_to_comment = np.random.choice(
                total_posts, comment_sample_distributions[i])
            posts_to_react = np.random.choice(
                total_posts, reaction_sample_distribuions[i])

            like_or_no_like = np.random.default_rng().random(
                max(len(posts_to_react), len(posts_to_comment))) > 0.2

            # adding comments
            for j in range(posts_to_comment.size):
                post_id = posts_to_comment[j]
                response_date = fake.date_time_between(start_date=min(
                    posts[post_id]['date'], created_at), end_date='now', tzinfo=None)
                comments.append({
                    "post_id": 1 + int(post_id),
                    "user_id": user_id,
                    "content": fake.sentence(100, True),
                    "date": response_date
                })
                reactions.append({
                    "post_id": 1 + int(post_id),
                    "user_id": user_id,
                    "like": bool(like_or_no_like[j]),
                    "created_at": response_date
                })
                viewed_posts.add(post_id)

            # adding reactions
            for j in range(posts_to_react.size):
                post_id = posts_to_react[j]
                if post_id in viewed_posts:
                    continue

                response_date = fake.date_time_between(start_date=min(
                    posts[post_id]['date'], created_at), end_date='now', tzinfo=None)
                reactions.append({
                    "post_id": 1 + int(post_id),
                    "user_id": user_id,
                    "like": bool(like_or_no_like[j]),
                    "created_at": response_date
                })

            # adding followers
            people_to_follow = np.random.choice(
                i, follower_sample_distributions[i])
            for follow_id in people_to_follow:
                followers.append({
                    "created_at": fake.date_time_between(start_date=created_at, end_date='now', tzinfo=None),
                    "user_id": 1 + int(follow_id),
                    "follower_id": user_id
                })

    if posts:
        conn.execute(sqlalchemy.text("""
        INSERT INTO "Posts" (post, user_id, date)
        VALUES (:post, :user_id, :date);
        """), posts)
    if comments:
        conn.execute(sqlalchemy.text("""
        INSERT INTO "Comments" (post_id, user_id, content, date)
        VALUES (:post_id, :user_id, :content, :date)
        """), comments)
    if followers:
        conn.execute(sqlalchemy.text("""
        INSERT INTO "Followers" (created_at, user_id, follower_id)
        VALUES (:created_at, :user_id, :follower_id)
        """), followers)
    if reactions:
        conn.execute(sqlalchemy.text("""
        INSERT INTO "Reactions" (post_id, user_id, "like", created_at)
        VALUES (:post_id, :user_id, :like, :created_at)
        """), reactions)

    print("total posts: ", total_posts)
    print("total comments: ", len(comments))
    print("total users: ", num_users)
    print("total followers: ", len(followers))
    print("total reactions (likes / dislikes): ", len(reactions))
    # num users * 2 because Profile is created for each user
    print("total records", len(comments) + total_posts +
          (num_users * 2) + len(followers) + len(reactions))
